\documentclass[twoside,12pt,a4paper]{article}

\usepackage[OT1,T2A]{fontenc}
\usepackage[cp1251]{inputenc}

\usepackage[russian]{babel}
\usepackage{epsfig}
\usepackage{amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsxtra}
\usepackage{amsthm}
\usepackage[mathscr]{eucal}
\usepackage{tabularx}
\usepackage[table]{xcolor}
\usepackage{indentfirst}
\usepackage{listings}

\pagestyle{myheadings} \tolerance=750

\input{core/theorem_styles.tex}

\usepackage{geometry}
\geometry{left=2.1cm}
\geometry{right=2.8cm}
\geometry{top=2.8cm}
\geometry{bottom=2.8cm}

\begin{document}
\renewcommand{\refname}{\begin{center}{\normalsize\rm ЛИТЕРАТУРА}\end{center}}
\large

\begin{center}
\large{ОПТИМИЗАЦИЯ РАБОТЫ АНАЛИЗА ПСЕВДОНИМОВ В ОРС}
\end{center}

\markboth{\hfill Коненко А.\,С.\hfill}
{\hfill Оптимизация работы анализа псевдонимов в ОРС \hfill}

\addcontentsline{toc}{subsection}
{Коненко А.\,С. Оптимизация работы анализа псевдонимов в ОРС}

\begin{center}
\large{\bf Коненко А.\,С.}

\normalsize{\it Мехмат ЮФУ, Ростов-на-Дону}

\end{center}

\vspace{\baselineskip}
\normalsize
TODO: I don't know what I should do this.

\vspace{\baselineskip}
\large

\begin{mydefinition}
Анализ псевдонимов -- это комплекс алгоритмов, работающих в компиляторе, который позволяет получать информацию о ряде важных взаимоотношений между ячейками памяти и указателями на них.
\end{mydefinition}

Информация получаемая анализом псевдонимов необходима компилятору для ряда применений:
\begin{itemize}
\item уточнения результатов некоторых других анализов кода -- тех, которые в своей работе опираются на взаимоотношения между данными~\cite{konenko-Voevodin};
\item проверки предусловий применимости некоторых преобразований кода: некоторые преобразования невозможно применить при псевдонимной связи между данными в блоке, а некоторые, наоборот, в своей работе опираются на наличие таких связей;
\item для статических проверок программы на возможные ошибки.
\end{itemize}

\begin{myexamples}
\begin{enumerate}
\item В качестве примера анализа, который может уточнить свои результаты за счет анализа псевдонимов, можно привести анализ, вычисляющий объем памяти, необходимой для работы некоторому блоку кода. Во время его работы полезно знать, что какие-то из переменных в заданном блоке -- псевдонимы, и не считать дважды объем памяти, к которому обращаются с их помощью.
\item В качестве примера преобразования, которому необходима информация о псевдонимах, можно привести раскрутку цикла, которой необходимо, чтобы счетчик цикла не менялся в его теле, а следовательно там не существовало псевдонима с счетчику.
\item Возможной ошибкой, которую может обнаружить анализ псевдонимов, может быть ситуация, когда в функции две переменные всюду друг другу являются псевдонимами.
\end{enumerate}
\end{myexamples}

\begin{mydefinition}
Два указателя a и b будем называть псевдонимами, если они указывают на одну и ту же область памяти. Причем мы можем говорить об этом отношении с некоторой уверенностью, если анализ делает упрощения и пренебрежения точностью для ускорения работы и уменьшения потребления памяти, к примеру -- игнорирует контекст вызова процедур и функций.
\end{mydefinition}

\begin{mydefinition}
Контекстом вызова процедуры при анализе псевдонимов мы будем называть информацию о взаимоотношении между всеми ячейками памяти и всеми указателями, которые находятся в области видимости данной процедуры при вызове её из данного места какой-то процедуры. 
\end{mydefinition}

Целью анализа псевдонимов является статическое (на этапе компиляции) обнаружение всех псевдонимов в компилируемой программе и ответ на запросы о взаимоотношении для произвольных пар указателей (и, возможно, контекстов вызова функции), как соотносятся области памяти, на которые указывают эти указатели. Всего выделяют четыре взаимоотношения между указателями:
\begin{description}
  \item[MustAlias] Указатели точно указывают в одну область памяти, т.е. являются псевдонимами.
  \item[PartialAlias] Объекты, на которые они указывают пересекаются в памяти, но начинаются не с одного адреса.
  \item[MayAlias] Указатели могут указывать в одну область памяти.
  \item[NoAlias] Указатели точно указывают в разные области памяти.
\end{description}

\begin{ListingEnv}[h]
\lstset{language=C,breaklines=true, extendedchars=true, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize, frame=lines, keywordstyle=\bfseries\color{blue}, commentstyle=\color{green!50!black}}

\lstset{emph={classdef, properties, methods},emphstyle={\color{blue}\bfseries}}
\begin{lstlisting}
void f(int* a, int* X)
{
    int* p;
    int i;
    ...
    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
    ...
}
\end{lstlisting}
\caption{Пример функции, переданной для анализа}
\label{code:konenko_unfold}
\end{ListingEnv}

\begin{myexample}
Для примера рассмотрим функцию, приведенную в листинге~\ref{code:konenko_unfold}. Небольшое число итераций цикла может навести на мысль развернуть цикл, но это будет эквивалентным преобразованием, только если $a$, $p$ и $X$ точно не являются псевдонимами к $i$, т.е. в теле цикла счетчик цикла не может измениться. Как видно, информация, получаемая этим анализом, может предостеречь компилятор от преобразований, которые могут сделать программу не эквивалентной исходной. Подробнее этот пример будет разбираться во второй части этой работы.
\label{ex:konenko_unfold}
\end{myexample}

\begin{myremark}
Следует учитывать, что анализ псевдонимов исходит из того, что код программы не содержит элементов, которые могут привести к неопределенному поведению, т.е. таких элементов, например, как обращения к элементам, находящимся за границами массивов. В примере выше компилятору будет достаточно убедиться, что нигде в функции не берется адрес переменной $i$ и попытка выполнения, например, $p = \&p + 1$ (исходя из предположения, что переменные $i$ и $p$ соседи на стеке и лежат там именно в этом порядке) не будет воспринята как потенциальное создание псевдонима.
\end{myremark}

%\subsection{Классификация анализов псевдонимов}

Существует ряд классификаций анализов псевдонимов. Ниже приведены ключевые, которые, в частности, затрагивались в докладе~\cite{konenko-GohmanAAinLLVM} одного из разработчиков LLVM.

\begin{mydefinition}
Анализ называют чувствительным к контексту ($context$-$sensitive$), если он различает вызовы анализируемой функции с различными взаимоотношениями в смысле псевдонимов между указателями, находящимися в области видимости, и опираясь на контекст, строит результат с наибольшей возможной уверенностью об отношении. В обратном случае, если для процедуры строится один контекстно-независимый результат, который верен для любого контекста вызова, но консервативен, т.е. даёт много $MayAlias$ ответов на запросы, анализ называют нечувствительным к контексту ($context$-$insensitive$).
\end{mydefinition}

\begin{mydefinition}
Анализ называют чувствительным к потоку управления ($flow$-$sensitive$), если он чувствителен к местам вхождений переданных указателей при ответе на запросы по результату анализа, иначе он является нечувствительным к потоку управления ($flow$-$insensitive$), т.е. имеющим представление только о конечном взаимоотношении между этими указателями, но не имеющим промежуточных результатов.
\end{mydefinition}

\begin{mydefinition}
Анализ называют чувствительным к полям структур ($field$-$sensitive$), если он способен различать поля структур при анализе. В обратном случае, если псевдонимом к чему-либо является какой-то член структуры, а анализ объявляет псевдонимом всю структуру целиком, то анализ называется нечувствительным к полям структур ($field$-$insensitive$).
\end{mydefinition}

\begin{mydefinition}
Если анализ строится для языков, в которых отсутствуют сырые указатели и есть сильная система типов вроде Haskell или Java, то его строят на основе анализа типов и называют $type$-$based$. Если же анализ строится для языка, в котором есть сырые указатели и преобразования типов, вроде языков С/С++, то анализ строят на анализе потока управления программы, и такой анализ называют $flow$-$based$.
\end{mydefinition}

%--------------------------------------------------------------------------------------------------------------------
\section{Существующие подходы к анализу псевдонимов}

В ходе работы был изучен ряд подходов к анализу псевдонимов. В основном, это были алгоритмы реализованные в LLVM. 

\textit{BasicAA} -- один из базовых анализов, применяемых в LLVM; производит (по заявлениям документации~\cite{konenko-LLVMAAI}) агрессивный локальный анализ и исходит, в частности, из следующих предположений:
\begin{itemize}
\item Глобальные переменные, память выделенная на стеке и выделенная в динамической памяти никогда не пересекаются.
\item Различные поля структуры никогда не псевдонимы друг другу.
\item Большинство функций стандартной библиотеки Си не обращаются к памяти или только читают её.
\item Вызовы функций не могут модифицировать или ссылаться на части стека, которая выделена не для них.
\end{itemize}

\textit{Steensgaard’s algorithm} -- межпроцедурный анализ с хорошей скоростью работы, но с большим числом упрощений и обобщений. Он принадлежит к классу $unification$-$based$, т.е. его работа основа на присвоении классов переменным и их объединении на основе анализа программы. Из его описания в заметке~\cite{konenko-SteensgaardsNote} можно понять его сильные и слабые стороны. Его реализация также используется в LLVM в местах, где скорость работы важнее её точности. Принцип работы изображен на рисунке~\ref{fig:konenko_steensgaard}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{./imgs/konenko_steensgaard.jpg}
\caption{Демонстрация принципа работы алгоритма Стинсгарда.}
\label{fig:konenko_steensgaard}
\end{figure}

В работах Моники Лэм и Роберта Уилсона рассматривается такой подход к межпроцедурному анализу, как частично трансферные функции, который предлагает во время анализа функций строить отображения из контекста вызова в контекст, получаемый на выходе, что должно ускорять межпроцедурный анализ, отсекая повторные анализы вызовов функций не только с одним и тем же контекстом, но и с подобными тем, что уже были проанализированы.

При существовании в компиляторе нескольких реализаций анализа псевдонимов часто прибегают к их последовательному применению по цепочке, запуская более тяжеловесные алгоритмы для уточнения только критичных участков. Такой принцип, например, принят в инфраструктуре LLVM.

%--------------------------------------------------------------------------------------------------------------------
\section{Существующая реализация анализа в ОРС}

Оптимизирующая распараллеливающая система (ОРС), разрабатываемая на мехмате ЮФУ является экспериментальным исследовательским проектом, целью которого является изучение методов автоматической оптимизации программ. Как и прочие компиляторы, выполняющие в процессе своей работы анализ и преобразования программ, компилятор ОРС имеет в своём составе реализацию анализа псевдонимов.

Пользуясь описанной классификацией анализов, существующую в ОРС реализацию можно описать как $flow$-$based$, $context$-$sensitive$, $flow$-$sensitive$, $field$-$sensitive$ (по умолчанию; может быть и $field$-$insensitive$) анализ псевдонимов.

Существующая реализация достаточно точная, но весьма медленная и требует сравнительно большой объем памяти. Принцип её работы заключается в осуществлении обхода всех путей от входа до выходов в факторизованном графе потока управления всех функций. Во время обхода происходит накопление результатов частичного анализа и их комбинирование для создания конечного результата. Причем этот обход производится для каждого контекста, в котором вызывается функция. Такой подход позволяет строить достаточно точный анализ, так как по сути представляет собой практически полноценное выполнение всех функций.

Для упрощения работы с результатом работы анализа псевдонимов, в ОРС используется построение графа зависимостей. Этот граф используется не только компонентами компилятора, но и разработчики ОРС используют его визуализацию для анализа программ. На рисунках~\ref{fig:konenko_depgraphBad} и~\ref{fig:konenko_depgraphGood} приведены визуализации графов зависимостей для двух функций из листинга~\ref{code:konenko_fordepgraph}. На них мы можем увидеть подтверждение того, что говорилось в примере данном во введении. Многочисленные дуги из тела цикла в его заголовок отражают возможность изменения счетчика цикла, во время выполнения итерации, что мешает компилятору развернуть цикл, так как это преобразование может привести к неэквивалентной программе.
% деп.граф, анализ зависимостей. Основная масса анализов и преобразований используют АА через деп.граф.

\begin{ListingEnv}[h]
  \lstset{language=C,breaklines=true, extendedchars=true, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize, frame=lines, keywordstyle=\bfseries\color{blue}, commentstyle=\color{green!50!black}}

\lstset{emph={classdef, properties, methods},emphstyle={\color{blue}\bfseries}}
\begin{lstlisting}
int g(int* a, int* b)
{
    return *a * *b;
}

void f1(int* a, int* X)
{
    int* p;
    int i;
    
    p = &a;

    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
}

void f2(int* a, int* X)
{
    int* p;
    int i;
    
    p = &i;

    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
}
\end{lstlisting}
\caption{Пример анализируемого кода}
\label{code:konenko_fordepgraph}
\end{ListingEnv}

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{./imgs/konenko_opsDepGraphBad.jpg}
\caption{Граф зависимостей для f1}
\label{fig:konenko_depgraphBad}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{./imgs/konenko_opsDepGraphGood.jpg}
\caption{Граф зависимостей для f2}
\label{fig:konenko_depgraphGood}
\end{figure}

Как и многие другие части компилятора ОРС, модуль анализа псевдонимов имеет два набора тестов:
\begin{enumerate}
    \item Тесты производительности.
    \item Тесты корректности.
\end{enumerate}

Для тестирования производительности используются бенчмарки, являющиеся, по сути, исходными кодами реальных программ или их частей, которые подаются на вход компилятору; вслед за чем производится профилирование процесса выполнения. Например, одним из бенчмарков является \textit{quagga} -- пакет, реализующий протоколы динамической маршрутизации, используемый в UNIX-подобных операционных системах. Этот пакет был найден и добавлен в набор бенчмарков анализа псевдонимов ОРС автором в тот момент, когда обнаружился недостаток графовых и похожих на них по структуре алгоритмов среди уже имеющихся бенчмарков, а для проверки эффекта модификации процедурной части анализа были необходимы именно они.

При разработке ОРС используется модульное тестирование, которое помогает команде разработчиков контролировать корректность работы компилятора и избегать внесения ошибок в работающие части проекта при добавлении новой функциональности или модификации существующей. Так как в процессе своей работы автор внес изменения в интерфейс и поведение анализа псевдонимов, было необходимо внести изменения в тесты для того, чтобы они корректно использовали интерфейс анализа.

\section{Ускорение анализа}

В существующем анализе посредством профилирования, чтения кода и документации было обнаружено два перспективных направления модификаций, которые могли принести хорошие результаты, а именно за счет незначительного ухудшения качества увеличить скорость работы анализа. 
А именно:

В процедурной части анализа, в случаях, когда в функции имеется множество расходящихся и сразу же сходящихся веток, что свойственно, например, графовым алгоритмам, полный обход всех путей от входа до выхода занимает значительное время, так как время работы такого алгоритма эспоненциально, в зависимости от числа ветвлений в функции. В то же время, объем памяти, требуемой такому алгоритму растет линейно от числа вершин в фактор-графе потока управления.

Для решения этой проблемы была предпринята попытка применить некоторые идеи из алгоритма Стинсгарда и изменить логику обхода графа управления в пользу раннего слияния результатов анализа. Для этого в местах ветвления анализ пытается заглянуть вперед для нахождения ближайшего общего потомка веток и запланировать объединение в нём результатов анализа, а не в конце программы. Эта модификация, незначительно ухудшив результаты анализа (это поведение приводит к большему числу false positive ответов на запросы о соотношении указателей), привела к ускорению анализа функций, чья структура содержит много ветвлений, но вместе с тем существуют примеры, на которых анализ существенно замедлился. В таблице~\ref{tabl:konenko_Profiling} колонка с результатами запуска анализа с этой модификацией озаглавлена как \textit{слияние}. В листинге~\ref{code:konenko_manyifs} приведена схема функции, анализ которой получил ускорение за счет данной модификации.

\begin{ListingEnv}[ht]
  \lstset{language=C,breaklines=true, extendedchars=true, numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize, frame=lines, keywordstyle=\bfseries\color{blue}, commentstyle=\color{green!50!black}}

\lstset{emph={classdef, properties, methods},emphstyle={\color{blue}\bfseries}}
\begin{lstlisting}
void f(int* a, int* b)
{
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
}
\end{lstlisting}
\caption{Общий вид функций, анализ которых ускоряется за счет раннего слияния результатов обхода ветвей графа управления}
\label{code:konenko_manyifs}
\end{ListingEnv}

В межпроцедурной части анализа существующий алгоритм производит детальный анализ для каждого места вызова функции, что оказывается излишним в случае, если контекст вызовов не меняется.

Для решения второй проблемы первой идеей было воспользоваться наработками, описанными в работе Лэм и Вильсона~\cite{konenko-WilsonLamSIGPLAN95}, и анализировать контексты, для которых выполняются проверки, чтобы в случае вызова в подобных контекстах выполнять анализ однократно. Но полноценная реализация построения частично трансферных функций имела значительную трудоёмкость, поэтому было принято решение сначала, для проверки гипотезы, реализовать простое кэширование результата для одних и тех же контекстов вызова функции. Этот подход дал неплохие результаты: для тестов небольших размеров время построения результата анализа почти не изменилось, но на достаточно сложных бенчмарках с большим числом вызывающих друг друга функций время построения сократилось вдвое. В таблице~\ref{tabl:konenko_Profiling} колонка с результатами запуска анализа с этой модификацией озаглавлена как \textit{кэширование}.

\Conc

В таблице 1 представлены результаты тестирования скорости построения результата анализа для исходного алгоритма, двух созданных модификаций и их комбинации. Числа в клетках - среднее время в миллисекундах, которое потребовалось на построение результата анализа для соответствующего бенчмарка на 20 запусках. Зеленым в таблице выделены результаты в два и более раз лучше эталона, а красным отмечен серьезный проигрыш производительности.

Сборка проекта осуществлялась g++ 4.9.2 на Ubuntu 15.04. Компьютер, на котором осуществлялось тестирование, имеет процессор Intel(R) Core(TM) i7-4700MQ с тактовой частотой 2.4 GHz и автоматическим её увеличением до 3.4 GHz. Нужно отметить, что так как алгоритмы анализа псевдонимов в ОРС работают в одном потоке, частота процессора играет большую роль, чем число ядер.

\begin{table}[ht]
\begin{tabular}{l | c | c | c | c }
Бенчмарк & Исходная реализация & Слияние & Кэширование & Оба \\
\hline \hline
linpack     & 193 & 189                    & 184                    & 183 \\
md          & 46  & 44                     & 40                     & 40\\ 
whetstone   & 81  & 78                     & 75                     & 76\\
smith       & 211 & \textcolor{green}{117} & \textcolor{green}{98}  & 97\\
gazaryan    & 249 & 260                    & \textcolor{green}{92}  & 96\\
revrina     & 191 & 192                    & \textcolor{green}{67}  & 68\\
lbm         & 446 & \textcolor{red}{4474}  & 341                    & 4490\\
hirschberg  & 604 & 570                    & \textcolor{green}{309} & 306\\
hirschberg2 & 104 & 103                    & \textcolor{green}{50}  & 51\\
quagga      & 23  & \textcolor{green}{6}   & 22                     & 6
\end{tabular}
\caption{Результаты тестирования}
\label{tabl:konenko_Profiling}
\end{table}

\begin{thebibliography}{99}
\normalsize
  
\bibitem{konenko-Voevodin}
    {\it Воеводин В.\,В, Воеводин, В.\,В.\/} Параллельные вычисления.: БХВ-Петербург, 2002

\bibitem{konenko-GohmanAAinLLVM}
  {\it Dan Gohman} Alias Analysis in LLVM //
  LLVM Developers' Meeting 2012

\bibitem{konenko-LLVMAAI}
  LLVM Alias Analysis Infrastructure. [Электронный ресурс] URL: http://llvm.org/docs/AliasAnalysis.html#the-basicaa-pass (Дата обращения: 20.04.2015)

\bibitem{konenko-SteensgaardsNote}
  Note on Steensgaard's Point-to Analysis. [Электронный ресурс] URL: http://courses.cs.washington.edu/courses/cse590md/01sp/stenote.pdf (Дата обращения: 13.03.2015)

\bibitem{konenko-WilsonLamSIGPLAN95}
  {\it Robert P. Wilson, Monica S. Lam} Efficient Context-Sensitive Pointer Analysis for C Program // PLDI. 1995

\bibitem{konenko-Drozdov2010}
  {\it Дроздов А.\,Ю.\/} Компонентный подход к построению оптимизирующих компиляторов. М. 2010

\end{thebibliography}

\end{document}
