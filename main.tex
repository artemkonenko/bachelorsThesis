% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Анализ псевдонимов - это комплекс алгоритмов, работающих в компиляторе, который позволяет получать информацию о ряде важных взаимоотношений между ячейками памяти и указателями на них, необходимых для преобразований кода и ряда других анализов.
% * <roman.accs@gmail.com> 2015-06-21T16:59:48.017Z:
%
%  Эта информация необходима ...
%
% * <roman.accs@gmail.com> 2015-06-21T16:59:05.736Z:
%
%  - и ,
%

Задачей настоящей бакалаврской работы является исследование темы анализа псевдонимов и оптимизация работы анализа псевдонимов в ОРС - исследовательском оптимизирующем компиляторе языков Си и Фортран.

%\section{Определение}
%\label{sec:examples}

%\subsection{Псевдонимы и необходимость анализа}

Два указателя a и b будем называть псевдонимами, если они указывают на одну и ту же область памяти. Причем мы можем говорить об этом отношении с некоторой уверенностью, если анализ делает упрощения и пренебрежения точностью для ускорения работы и уменьшения потребления памяти, к примеру игнорирует контекст вызова процедур.

Контекстом вызова процедуры при анализе псевдонимов мы будем называть информацию о взаимоотношении между всеми ячейками памяти и всеми указателями, которые находятся в области видимости данной процедуры, при вызове её из конкретного места другой процедуры. 

Целью анализа псевдонимов является статическое (на этапе компиляции) определение для каждой пары указателей и, возможно, контекстов вызова функции, как взаимоотносятся области памяти в которые указывают эти указатели. Всего выделяют четыре взаимоотношения между указателями:
% * <roman.accs@gmail.com> 2015-06-21T16:56:04.664Z:
%
%  соотносяться
%
% ^ <roman.accs@gmail.com> 2015-06-21T16:56:48.666Z:
%
%  соотносятся
%
\begin{description}
  \item[MustAlias] Указатели точно указывают в одну область памяти, т.е. являются псевдонимами.
  \item[PartialAlias] Объекты, на которые они указывают пересекаются в памяти, но начинаются не с одного адреса.
  \item[MayAlias] Указатели могут указывать в одну область памяти.
  \item[NoAlias] Указатели точно указывают в разные области памяти.
\end{description}

\begin{ListingEnv}[H]
\begin{lstlisting}
int* f(int* a, int* b)
{
    if (*a > *b)
    {
        *b = 0;
        return a;
    }
    else
    {
        *a = 0;
        return b;
    }
}
\end{lstlisting}
\caption{Пример программы для анализа}
\label{list:otherlevels}
\end{ListingEnv}

Для примера рассмотрим функцию приведенную в листинге 1, которая обнуляет меньший из двух аргументов переданных по указателю и возвращает указатель на больший. Можно заметить, что если фактические параметры функции f окажутся псевдонимами, то ячейка памяти на которую они указывают будет обнулена. Эта информация может предостеречь компилятор от преобразований, которые могут в результате работы этой функции стать не эквивалентными.

Результат анализа псевдонимов имеет ряд применений:
\begin{itemize}
\item для уточнения результатов других анализов существующих в компиляторе.
\item для проверки условий применимости преобразований кода программы: некоторые преобразования невозможно сделать при псевдонимной связи между данными в блоке, а некоторые, наоборот, в своей работы опираются на наличие таких связей.
\item для статических проверок программы на возможные ошибки.
\end{itemize}

%\subsection{Классификация анализов псевдонимов}

Существует ряд классификаций анализов псевдонимов. Ниже приведены ключевые, которые, в частности, затрагивались в докладе~\autocite{GohmanAAinLLVM} одного из разработчиков LLVM.

Анализ называют чувствительным к контексту -- $context$-$sensitive$, если он различает вызовы анализируемой функции с различными взаимоотношениями в смысле псевдонимов между указателями, находящимися в области видимости и, опираясь на контекст, построить результат с наибольшей возможной уверенностью об отношении. В обратном случае, если для процедуры строится один контекстно-независимый результат, который верен для любого контекста вызова, но пессимистичен, т.е. содержит много $MayAlias$ результатов, анализ называют не чувствительным к контексту -- $context$-$insensitive$.
% * <roman.accs@gmail.com> 2015-06-21T17:04:50.399Z:
%
%  входными параметрами, видимо
%

Анализ называют $flow$-$sensitive$, если он чувствителен к местам вхождений переданных указателей при ответе на запросы по результату анализа, иначе он является $flow$-$insensitive$, т.е. имеющим представление только о конечном взаимоотношении, но не имеющим промежуточных результатов.

Анализ называют чувствительным к полям структур -- $field$-$sensitive$, если он способен различать поля структур при анализе. В обратном случае, если псевдонимом к чему-либо является какой-то член структуры, а анализ объявляет псевдонимом всё структуру целиком, то анализ называется не чувствительным к полям структур -- $field$-$insensitive$.

Если анализ строится для языков вроде Haskell или Java, в которых отсутствуют сырые указатели и есть сильная система типов, то его строят на основе анализа типов и называют $type$-$based$. Если же анализ строится для языка, в котором есть сырые указатели и преобразования типов, вроде языков С/С++, то анализ строят на анализе потока управления программы и такой анализ называют $flow$-$based$.

%--------------------------------------------------------------------------------------------------------------------
\section{Анализ существующих подходов к анализу псевдонимов}

В ходе работы был изучен ряд подходов к анализу псевдонимов. В основном это были алгоритмы реализованные в LLVM. 

$BasicAA$ -- Баланс между скоростью и числом упрощений.

$Steensgaard’s algorithm$ -- межпроцедурный анализ с хорошей скоростью работы, но с большим числом упрощений и обобщений. Из его описания в заметке ~\autocite{SteensgaardsNote} можно понять его сильные и слабые стороны. Его реализация так же используется в LLVM в местах, где точность не очень важна.

Так же были изучены работы Моники Лэм и Роберта Уилсона  в которых рассматривался такой подход к межпроцедурному анализу, как частично трансферные функции, который предлагает во время анализа функций строить отображения из контекста вызова в контекст, получаемый на выходе, что должно ускорять межпроцедурный анализ, отсекая повторные анализы вызовов функций не только с одним и тем же контекстом, но и подобными ему.

При существовании в компиляторе нескольких реализаций анализа псевдонимов часто прибегают к их последовательному применению по цепочке, запуская более тяжеловесные алгоритмы для уточнения только критичных участков.

%--------------------------------------------------------------------------------------------------------------------
\section{Существующая реализация анализа в ОРС}

Пользуясь описанной классификацией анализов существующую реализацию можно описать как flow-based, context-insensitive, flow-sensitive, field-sensitive (по умолчанию. Может быть и field-insensitive) анализ псевдонимов.

Существующая реализация достаточно точная, но весьма медленная с большим потреблением памяти.

\section{Ускорение анализа, параллельная реализация, чтобы нам сломать}

В существующей реализации было найдено два узких места:

\begin{itemize}
\item При большом ветвлении конец подпрограммы просматривается значительное число раз.
\item Подпрограмма анализируется при каждом её вызове.
\end{itemize}

Для обхода первого узкого места была усложнена логика обхода графа управления, которая теперь в местах ветвления пытается заглянуть вперед для нахождения более близкой точки объединения результатов анализа, нежели конец программы.

Для решения же второй проблемы была предпринята попытка воспользоватся идеями описанными в работе Лэм и Вильсона~\autocite{WilsonLamSIGPLAN95} и анализировать контексты для которых выполняются проверки, чтобы в случае вызова в одинаковых контекстах выполнять анализ однократно.

\Conc

Изменение обхода графа управления в процедуре не принесло большого выигрыша на основной массе тестов. Хорошо этот подход показал себя только на процедурах специального вида, где подряд много раз производится ветвление, а затем объединение.

\begin{ListingEnv}[H]
\begin{lstlisting}
void f(int* a, int* b)
{
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
}
\end{lstlisting}
\caption{Общий вид функций, анализ которых ускоряется за счет раннего слияния результатов обхода ветвей графа управления}
\label{list:otherlevels}
\end{ListingEnv}

А вот применение идеи кэширования результатов анализа процедуры для контекстов дало выигрыш на всех достаточно сложных примерах.


% Печать списка литературы (библиографии)
\printbibliography[
    heading=bibintoc%
    ,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}