% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

% Задачей настоящей бакалаврской работы является исследование темы анализа псевдонимов и оптимизация работы анализа псевдонимов в ОРС - исследовательском оптимизирующем компиляторе языков Си и Фортран.

\begin{mydefinition}
Анализ псевдонимов -- это комплекс алгоритмов, работающих в компиляторе, который позволяет получать информацию о ряде важных взаимоотношений между ячейками памяти и указателями на них.
\end{mydefinition}

Информация получаемая анализом псевдонимов необходима для ряда применений:
\begin{itemize}
\item уточнения некоторых других анализов кода -- тех, которые в своей работе опираются на взаимоотношения между данными~\autocite{Voevodin}.
\item проверки предусловий применимости некоторых преобразований кода: некоторые преобразования невозможно сделать при псевдонимной связи между данными в блоке, а некоторые, наоборот, в своей работе опираются на наличие таких связей.
\item для статических проверок программы на возможные ошибки.
\end{itemize}

\begin{myexamples}
\begin{enumerate}
\item В качестве примера анализа, который может уточнить свои результаты за счет анализа псевдонимов, можно привести анализ, вычисляющий объем памяти необходимой для работы некоторому блоку кода. Во время его работы полезно знать, что какие-то из переменных в заданном блоке -- псевдонимы.
\item В качестве примера преобразования, которому необходима информация о псевдонимах можно привести раскрутку цикла, которой необходимо, чтобы счетчик цикла не менялся в его теле.
\item Возможной ошибкой, которую может обнаружить анализ псевдонимов, может быть ситуация, когда в функции две переменные всюду друг другу псевдонимы.
\end{enumerate}
\end{myexamples}

\begin{mydefinition}
Два указателя a и b будем называть псевдонимами, если они указывают на одну и ту же область памяти. Причем мы можем говорить об этом отношении с некоторой уверенностью, если анализ делает упрощения и пренебрежения точностью для ускорения работы и уменьшения потребления памяти, к примеру -- игнорирует контекст вызова процедур.
\end{mydefinition}

\begin{mydefinition}
Контекстом вызова процедуры при анализе псевдонимов мы будем называть информацию о взаимоотношении между всеми ячейками памяти и всеми указателями, которые находятся в области видимости данной процедуры при вызове её из данного места какой-то процедуры. 
\end{mydefinition}

Целью анализа псевдонимов является статическое (на этапе компиляции) определение для каждой пары указателей и, возможно, контекстов вызова функции, как соотносятся области памяти на которые указывают эти указатели. Всего выделяют четыре взаимоотношения между указателями:
\begin{description}
  \item[MustAlias] Указатели точно указывают в одну область памяти, т.е. являются псевдонимами.
  \item[PartialAlias] Объекты, на которые они указывают пересекаются в памяти, но начинаются не с одного адреса.
  \item[MayAlias] Указатели могут указывать в одну область памяти.
  \item[NoAlias] Указатели точно указывают в разные области памяти.
\end{description}

\begin{ListingEnv}[H]
\begin{lstlisting}
void f(int* a, int* X)
{
    int* p;
    int i;
    ...
    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
    ...
}
\end{lstlisting}
\caption{Пример функции переданной для анализа}
\label{code:unfold}
\end{ListingEnv}

\begin{myexample}
Для примера рассмотрим функцию приведенную в листинге~\ref{code:unfold}. Небольшое число число итерации цикла может навести на мысль развернуть цикл, но это будет эквивалентным преобразрованием, только если $a$, $p$ и $X$ точно не являются псевдонимами к $i$, т.е. в теле цикла счетчик цикла не может изменится. Как видно, информация получаемая этим анализом может предостеречь компилятор от преобразований, которые могут сделать программу не эквивалентной исходной. Подробнее этот пример будет разбиратся во второй части этой работы.
\label{ex:unfold}
\end{myexample}

\begin{myremark}
Следует учитывать, что анализ псевдонимов исходит из того, что код программы не содержит элементов, которые могут привести к неопределенному поведению, т.е. таких элементов, например, как обращения к элементам находящимся за границами массивов. В примере выше компилятору будет достаточно убедится, что нигде в функции не берется адрес переменной $i$ и попытка выполнения, например, $p = \&p + 1$ (исходя из предположения, что переменные $i$ и $p$ соседи на стеке и лежат там именно в этом порядке) будет пропущена как потенциальное создание псевдонима.
\end{myremark}

%\subsection{Классификация анализов псевдонимов}

Существует ряд классификаций анализов псевдонимов. Ниже приведены ключевые, которые, в частности, затрагивались в докладе~\autocite{GohmanAAinLLVM} одного из разработчиков LLVM.

\begin{mydefinition}
Анализ называют чувствительным к контексту ($context$-$sensitive$), если он различает вызовы анализируемой функции с различными взаимоотношениями в смысле псевдонимов между указателями находящимися в области видимости и опираясь на контекст строит результат с наибольшей возможной уверенностью об отношении. В обратном случае, если для процедуры строится один контекстно-независимый результат, который верен для любого контекста вызова, но консервативен, т.е. даёт много $MayAlias$ ответов на запросы, анализ называют не чувствительным к контексту ($context$-$insensitive$).
\end{mydefinition}

\begin{mydefinition}
Анализ называют чувствительным к потоку управления ($flow$-$sensitive$), если он чувствителен к местам вхождений переданных указателей при ответе на запросы по результату анализа, иначе он является не чувствительным к потоку управления ($flow$-$insensitive$), т.е. имеющим представление только о конечном взаимоотношении между этими указателями, но не имеющим промежуточных результатов.
\end{mydefinition}

\begin{mydefinition}
Анализ называют чувствительным к полям структур ($field$-$sensitive$), если он способен различать поля структур при анализе. В обратном случае, если псевдонимом к чему-либо является какой-то член структуры, а анализ объявляет псевдонимом всё структуру целиком, то анализ называется нечувствительным к полям структур ($field$-$insensitive$).
\end{mydefinition}

\begin{mydefinition}
Если анализ строится для языков, в которых отсутствуют сырые указатели и есть сильная система типов вроде Haskell или Java, то его строят на основе анализа типов и называют $type$-$based$. Если же анализ строится для языка, в котором есть сырые указатели и преобразования типов, вроде языков С/С++, то анализ строят на анализе потока управления программы и такой анализ называют $flow$-$based$.
\end{mydefinition}

%--------------------------------------------------------------------------------------------------------------------
\section{Существующие подходы к анализу псевдонимов}

В ходе работы был изучен ряд подходов к анализу псевдонимов. В основном это были алгоритмы реализованные в LLVM. 

\textit{BasicAA} -- Один из базовых анализов применяемых в LLVM и производящий по заявлениям документации~\autocite{LLVMAAI} агрессивный локальный анализ и исходящий, в частности из следующих предположений:
\begin{itemize}
\item Глобальные переменные, память выделенная на стеке и в динамической памяти никогда не пересекается.
\item Различные поля структуры никогда не псевдонимы друг другу.
\item Большинство функций стандартной библиотеки Си не обращаются к памяти или только читают её.
\item Вызовы функций не могут модифицировать или ссылаться на части стека, которая выделена не для них.
\end{itemize}

\textit{Steensgaard’s algorithm} -- межпроцедурный анализ с хорошей скоростью работы, но с большим числом упрощений и обобщений. Он принадлежит к классу $unification$-$based$, т.е. его работа основа на присвоении классов переменным и их объединении на основе анализа программы. Из его описания в заметке~\autocite{SteensgaardsNote} можно понять его сильные и слабые стороны. Его реализация так же используется в LLVM в местах, где скорость работы важнее её точности. Принцип работы изображен на рисунке~\ref{fig:steensgaard}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/steensgaard.jpg}
\caption{Демонстрация принципа работы алгоритма Стинсгарда}
\label{fig:steensgaard}
\end{figure}

В работах Моники Лэм и Роберта Уилсона рассматривается такой подход к межпроцедурному анализу, как частично трансферные функции, который предлагает во время анализа функций строить отображения из контекста вызова в контекст, получаемый на выходе, что должно ускорять межпроцедурный анализ, отсекая повторные анализы вызовов функций не только с одним и тем же контекстом, но и с подобными тем, что уже были проанализированны.

При существовании в компиляторе нескольких реализаций анализа псевдонимов часто прибегают к их последовательному применению по цепочке, запуская более тяжеловесные алгоритмы для уточнения только критичных участков. Такой принцип, например, принят в инфраструктуре LLVM.

%--------------------------------------------------------------------------------------------------------------------
\section{Существующая реализация анализа в ОРС}

Оптимизирующая распараллеливающая система (ОРС) разрабатываемая на мехмате ЮФУ является экспериментальным исследовательским проектом, целью которого является изучение методов автоматической оптимизации программ. Как и прочие компиляторы выполняющие в процессе своей работы анализ и преобразования программ, компилятор ОРС имеет в своём составе реализацию анализа псевдонимов.

Пользуясь описанной классификацией анализов, существующую в ОРС реализацию можно описать как $flow$-$based$, $context$-$sensitive$, $flow$-$sensitive$, $field$-$sensitive$ (по умолчанию. Может быть и $field$-$insensitive$) анализ псевдонимов.

Существующая реализация достаточно точная, но весьма медленная и требует сравнительно большой объем памяти. Принцип её работы заключается в осуществлении обхода всех путей от входа до выходов в факторизованном графе потока управления всех функций. Во время обхода происходит накопление результатов частичного анализа и их комбинирование для создания конечного результата. Причем этот обход производится для каждого контекста, в котором вызывается функция. Такой подход позволяет строить достаточно точный анализ, так как по сути представляет собой практически полноценное выполнение всех функций.

Для упрощения работы с результатом работы анализа псевдонимов, в ОРС используется построение графа зависимостей. Этот граф используется не только компонентами компилятора, но и разработчики ОРС используют его визуализацию для анализа программ. На рисунках~\ref{fig:depgraphBad} и~\ref{fig:depgraphGood} приведены визуализации графов зависимостей для двух функций из листинга~\ref{code:fordepgraph}, на которых мы можем увидеть подтверждение утверждения данного в примере из введения. Многочисленные дуги из тела цикла в его заголовок иллюстрируют возможность изменения счетчика цикла, что мешает компилятору развернуть цикл, так как это преобразование может привести к неэквивалентной программе.
% деп.граф, анализ зависимостей. Основная масса анализов и преобразований используют АА через деп.граф.

\begin{ListingEnv}[H]
\begin{lstlisting}
int g(int* a, int* b)
{
    return *a * *b;
}

void f1(int* a, int* X)
{
    int* p;
    int i;
    
    p = &a;

    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
}

void f2(int* a, int* X)
{
    int* p;
    int i;
    
    p = &i;

    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
}
\end{lstlisting}
\caption{Пример анализируемого кода}
\label{code:fordepgraph}
\end{ListingEnv}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img/opsDepGraphBad_alpha.png}
\caption{Граф зависимостей для f1}
\label{fig:depgraphBad}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img/opsDepGraphGood_alpha.png}
\caption{Граф зависимостей для f2}
\label{fig:depgraphGood}
\end{figure}

Как и многие другие части компилятора ОРС модуль анализа псевдонимов имеет два набора тестов:
\begin{enumerate}
    \item Тесты производительности.
    \item Тесты корректности.
\end{enumerate}

Для тестирования производительности используются бенчмарки, являющиеся, по сути, исходными кодами реальных программ или их частей, которые подаются на вход компилятору и производится профилирование процесса выполнения. Например, одним из бенчмарков является \textit{quagga} -- пакет реализующий протоколы динамической маршрутизации, используемый в UNIX подобных операционных системах. Этот пакет был найден и добавлен в набор бенчмарков анализа псевдонимов ОРС автором в тот момент, когда обнаружился недостаток графовых и похожих на них по структуре алгоритмов среди уже имеющихся бенчмарков, а для проверки эффекта модификации процедурной части анализа были необходимы именно они.
% откуда взялись бенчмарки и почему было принято решение тестировать анализ с их помощью (это реальные программы)

При разработке ОРС используется модульное тестирование, которое помогает команде разработчиков контролировать корректность работы компилятора и избегать внесения ошибок в работающие части проекта, при добавлении новой функциональности или модификации существующей. Так как в процессе своей работы автор внес изменения в интерфейс и поведение анализа псевдонимов, было необходимо внести изменения в тесты для того, чтобы они корректно использовали интерфейс анализа.
% модульное тестирование.

\section{Ускорение анализа}

В существующем анализе посредством профилирования, чтения кода и документации было обнаружено два перспективных направления модификаций, которые могли принести хорошие результаты, а именно за счет незначительного ухудшения качества увеличить скорость работы анализа. А именно:

В процедурной части анализа, в случаях, когда в функции имеется множество расходящихся и сразу же сходящихся веток, что свойственно, например, графовым алгоритмам, полный обход всех путей от входа до выхода занимает значительное время, так время работы такого алгоритма эспоненциально растет от числа ветвлений в функции. В то же время, объем памяти требуемой такому алгоритму растет линейно от числа вершин в фактор-графе потока управления.

Для решения этой проблемы была предпринята попытка применить некоторые идеи из алгоритма Стинсгарда и изменить логику обхода графа управления в пользу раннего слияния результатов анализа. Для этого в местах ветвления анализ пытается заглянуть вперед для нахождения ближайшего общего потомка веток и запланировать объединение в нём результатов анализа, а не в конце программы. Эта модификация, незначительно ухудшив результаты анализа (это поведение приводит к большему числу false positive ответов на запросы о соотношении указателей), привела с ускорению анализа функций, чья структура содержит много ветвлений, но, вместе с тем, существуют примеры, на которых анализ существенно замедлился. В таблице~\ref{tabl:Profiling} колонка с результатами запуска анализа с этой модицикацией озаглавлена как \textit{слияние}. В листинге~\ref{code:manyifs} приведена схема функции, анализ которой получил ускорение за счет данной модификации.

\begin{ListingEnv}[ht]
\begin{lstlisting}
void f(int* a, int* b)
{
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
}
\end{lstlisting}
\caption{Общий вид функций, анализ которых ускоряется за счет раннего слияния результатов обхода ветвей графа управления}
\label{code:manyifs}
\end{ListingEnv}

В межпроцедурной части анализа существующий алгоритм производит детальный анализ для каждого места вызова функции, что оказывается излишним в случае, если контекст вызовов не меняется.

Для решения второй проблемы первой идеей было воспользоваться наработками описанными в работе Лэм и Вильсона~\autocite{WilsonLamSIGPLAN95} и анализировать контексты для которых выполняются проверки, чтобы в случае вызова в подобных контекстах выполнять анализ однократно. Но полноценная реализация построения частично трансферных функций имела значительную трудоёмкость, поэтому было принято решение сначала, для проверки гипотезы, реализовать простое кэширование результата для одних и тех же контекстов вызова функции. Этот подход дал неплохие результаты: для тестов небольших размеров скорость построения результата анализа почти не изменилась, но на достаточно сложных бенчмарках, с большим числом вызывающих друг друга функций скорость удвоилась. В таблице~\ref{tabl:Profiling} колонка с результатами запуска анализа с этой модицикацией озаглавлена как \textit{кэширование}.

\Conc

В таблице 1 представлены результаты тестирования скорости построения результата анализа для исходного алгоритма, двух созданных модификаций и их комбинации. Числа в клетках - среднее время в миллисекундах, которое потребовалось на построение результата анализа для соответствующего бенчмарка на 20 запусках.

Сборка проекта осуществлялась g++ 4.9.2 на Ubuntu 15.04. Компьютер на котором осуществлялось тестирование имеет процессор Intel(R) Core(TM) i7-4700MQ с тактовой частотой 2.4 GHz и автоматическим её увеличением до 3.4 GHz. Нужно отметить, что так как алгоритмы анализа псевдонимов в ОРС работают в одном потоке, частота процессора играет большую роль, чем число ядер.

\begin{table}[ht]
\begin{tabular}{l | c | c | c | c }
Бенчмарк & Исходная реализация & Слияние & Кэширование & Оба \\
\hline \hline
linpack     & 193 & 189                    & 184                    & 183 \\
md          & 46  & 44                     & 40                     & 40\\ 
whetstone   & 81  & 78                     & 75                     & 76\\
smith       & 211 & \textcolor{green}{117} & \textcolor{green}{98}  & 97\\
gazaryan    & 249 & 260                    & \textcolor{green}{92}  & 96\\
revrina     & 191 & 192                    & \textcolor{green}{67}  & 68\\
lbm         & 446 & \textcolor{red}{4474}  & 341                    & 4490\\
hirschberg  & 604 & 570                    & \textcolor{green}{309} & 306\\
hirschberg2 & 104 & 103                    & \textcolor{green}{50}  & 51\\
quagga      & 23  & \textcolor{green}{6}   & 22                     & 6
\end{tabular}
\caption{Результаты тестирования}
\label{tabl:Profiling}
\end{table}

\newpage % Почему-то библиография накладывалась на таблицу. Быть не должно этого тут.

% Печать списка литературы (библиографии)
\printbibliography[
    heading=bibintoc%
    ,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
