% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Задачей настоящей бакалаврской работы является оптимизация работы анализа псевдонимов в ОРС.

\section{Определение}
\label{sec:examples}

\subsection{Что такое псевдонимы и зачем нужен анализ}

Два указателя a и b будем называть псевдонимами, если они указывают на одну и ту же область памяти. При этом мы можем это делать с некоторой уверенностью, если наш анализ делает упрощения и пренебрежения точностью.

\begin{lstlisting}
int* f(int* a, int* b)
{
    if (*a > 0)
    {
        *b = 0;
        return a;
    }
    else
    {
        *a = 0;
        return b;
    }
}

int main()
{
    int a = 1;
    int b = -1;

    int* c = f(&a, &b);
    int* d = f(&b, c);


    return 0;
}
\end{lstlisting}

В данном примере можно заметить, что если фактические параметры функции f окажутся псевдонимами, то ячейка памяти на которую они указывают будет обнулена. Ну и прочие любопытные замечания про этот наскоро написанный пример.

Целью анализа псевдонимов/алиасов является статическое (на этапе компиляции) определение для каждой пары указателей и, возможно, контекста вызова функции, как взаимоотносятся области памяти в которые указывают эти указатели. Всего выделяют четыре взаимоотношения:
\begin{description}
  \item[MustAlias] Указатели точно указывают в одну область памяти, т.е. являются псевдонимами.
  \item[PartialAlias] Объекты, на которые они указывают пересекаются в памяти, но начинаются не с одного адреса.
  \item[MayAlias] Указатели могут указывать в одну область памяти.
  \item[NoAlias] Указатели точно указывают в разные области памяти.
\end{description}

Результат анализа псевдонима имеет ряд применений:
\begin{itemize}
\item для уточнения результатов других анализов существующих в компиляторе.
\item для проверки условий применимости преобразований кода программы: некоторые преобразования невозможно сделать при псевдонимной связи между данными в блоке, а некоторые, наоборот, в своей работы опираются на наличие таких связей.
\item для статических проверок программы на возможные ошибки.
\end{itemize}

\subsection{Классификация анализов псевдонимов}

Анализ называют чувствительным к контексту (context-sensitive), если он различает вызовы анализируемой функции с различными взаимоотношениями между параметрами в смысле псевдонимов. В обратном случае, если для процедуры строится один контекстно-независимый результат, анализ называют не чувствительным к контексту (context-insensitive).

Анализ называют flow-sensitive, если он чувствителен к местам вхождений переданных указателей при анализе, иначе он является flow-insensitive.

Анализ называют чувствительным к полям структур (field-sensitive), если он способен различать поля структур при анализе. В обратном случае, если псевдонимом считается сразу вся структура, то анализ называется не чувствительным к полям структур (field-insensitive).

Если анализ основан на анализе типов (для языков вроде Haskell или Java) его называют  type-based. Если же анализ строится для языка, в котором есть сырые указатели и преобразования типов, то анализ строят на анализе потока управления программы и такой анализ называют flow-based.

\subsection{Известные подходы к анализу псевдонимов (на примере LLVM)}

\begin{enumerate}
\item NoAA - На все запросы отвечать "я не знаю".
\item BasicAA - Баланс между скоростью и числом упрощений.
\item Steensgaard’s algorithm - межпроцедурный анализ с хорошей скоростью работы, но с большим числом упрощений.
\end{enumerate}

При использовании нескольких, анализы используются по цепочке, передавая свой результат следующему на вход.

\section{Существующая реализация анализа в ОРС}

Пользуясь описанной классификацией анализов существующую реализацию можно описать как flow-based, context-insensitive, flow-sensitive, field-sensitive (по умолчанию. Может быть и field-insensitive) анализ псевдонимов.

Существующая реализация достаточно точная, но весьма медленная с большим потреблением памяти.

\section{Ускорение анализа, параллельная реализация, чтобы нам сломать}

Есть идея пользуясь статьёй Лэм~\autocite{HeineLamPLDI03} и Вильсона

\Conc

В общем, дел тут непочатый край.

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
