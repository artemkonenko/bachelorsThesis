% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

% Задачей настоящей бакалаврской работы является исследование темы анализа псевдонимов и оптимизация работы анализа псевдонимов в ОРС - исследовательском оптимизирующем компиляторе языков Си и Фортран.

\begin{mydefinition}
Анализ псевдонимов -- это комплекс алгоритмов работающих, в компиляторе, который позволяет получать информацию о ряде важных взаимоотношений между ячейками памяти и указателями на них.
\end{mydefinition}

Информация получаемая анализом псевдонимов необходима для уточнения некоторых других анализов кода -- тех, которые в своей работе опираются на взаимоотношения между данными, и проверки предусловий применимости некоторых преобразований кода.

В качестве примера анализа, который может уточнить свои результаты за счет анализа псевдонимов, можно привести анализ вычисляющий объем памяти необходимой для работы некоторому блоку кода. Во время его работы полезно знать, что какие-то из переменных в заданном блоке -- псевдонимы.

В качестве примера преобразования, которое руководствуется результатом анализа псевдонимов можно привести работающее по следующему правилу: если две переменных всюду псевдонимы, то одну из них можно заменить на вторую тем самым уменьшив число переменных в коде

\begin{mydefinition}
Два указателя a и b будем называть псевдонимами, если они указывают на одну и ту же область памяти. Причем мы можем говорить об этом отношении с некоторой уверенностью, если анализ делает упрощения и пренебрежения точностью для ускорения работы и уменьшения потребления памяти, к примеру -- игнорирует контекст вызова процедур.
\end{mydefinition}

\begin{mydefinition}
Контекстом вызова процедуры при анализе псевдонимов мы будем называть информацию о взаимоотношение между всеми ячейками памяти и всеми указателями, которые находятся в области видимости данной процедуры при вызове её из данного места какой-то процедуры. 
\end{mydefinition}

Целью анализа псевдонимов является статическое (на этапе компиляции) определение для каждой пары указателей и, возможно, контекстов вызова функции, как взаимоотносятся области памяти на которые указывают эти указатели. Всего выделяют четыре взаимоотношения между указателями:
\begin{description}
  \item[MustAlias] Указатели точно указывают в одну область памяти, т.е. являются псевдонимами.
  \item[PartialAlias] Объекты, на которые они указывают пересекаются в памяти, но начинаются не с одного адреса.
  \item[MayAlias] Указатели могут указывать в одну область памяти.
  \item[NoAlias] Указатели точно указывают в разные области памяти.
\end{description}

\begin{ListingEnv}[H]
\begin{lstlisting}
int* f(int* a, int* X)
{
    int* p;
    int i;
    ...
    for (i=0; i < 8; ++i)
    {
        X[i] = g(a, p);
    }
    ...
    return p;
}
\end{lstlisting}
\caption{Пример функции переданной для анализа}
\end{ListingEnv}

Для примера рассмотрим функцию приведенную в листинге 0.1. Небольшое число число итерации цикла может навести на мысль развернуть цикл, но это будет эквивалентным преобразрованием, только если $a$, $p$ и $X$ не являются псевдонимами к $i$, т.е. в теле цикла счетчик цикла не меняется. Как видно, информация получаемая этим анализом может предостереч компилятор от преобразований, которые могут привести к не эквивалентной программе.

Результат анализа псевдонимов имеет ряд применений:
\begin{itemize}
\item для уточнения результатов других анализов существующих в компиляторе.
\item для проверки условий применимости преобразований кода программы: некоторые преобразования невозможно сделать при псевдонимной связи между данными в блоке, а некоторые, наоборот, в своей работы опираются на наличие таких связей.
\item для статических проверок программы на возможные ошибки.
\end{itemize}

%\subsection{Классификация анализов псевдонимов}

Существует ряд классификаций анализов псевдонимов. Ниже приведены ключевые, которые, в частности, затрагивались в докладе~\autocite{GohmanAAinLLVM} одного из разработчиков LLVM.

Анализ называют чувствительным к контексту -- $context$-$sensitive$, если он различает вызовы анализируемой функции с различными взаимоотношениями в смысле псевдонимов между указателями находящимися в области видимости и опираясь на контекст построить результат с наибольшей возможной уверенностью об отношении. В обратном случае, если для процедуры строится один контекстно-независимый результат, который верен для любого контекста вызова, но пессимистичен, т.е. содержит много $MayAlias$ результатов, анализ называют не чувствительным к контексту -- $context$-$insensitive$.

Анализ называют $flow$-$sensitive$, если он чувствителен к местам вхождений переданных указателей при ответе на запросы по результату анализа, иначе он является $flow$-$insensitive$, т.е. имеющим представление только о конечном взаимоотношении, но не имеющим промежуточных результатов.

Анализ называют чувствительным к полям структур -- $field$-$sensitive$, если он способен различать поля структур при анализе. В обратном случае, если псевдонимом к чему-либо является какой-то член структуры, а анализ объявляет псевдонимом всё структуру целиком, то анализ называется не чувствительным к полям структур -- $field$-$insensitive$.

Если анализ строится для языков вроде Haskell или Java, в которых отсутствуют сырые указатели и есть сильная система типов, то его строят на основе анализа типов и называют $type$-$based$. Если же анализ строится для языка, в котором есть сырые указатели и преобразования типов, вроде языков С/С++, то анализ строят на анализе потока управления программы и такой анализ называют $flow$-$based$.

%--------------------------------------------------------------------------------------------------------------------
\section{Анализ существующих подходов к анализу псевдонимов}

В ходе работы был изучен ряд подходов к анализу псевдонимов. В основном это были алгоритмы реализованные в LLVM. 

$BasicAA$ -- Базовый анализ применяемый в LLVM имеющим по заявлениям документации баланс между скоростью и числом упрощений.

$Steensgaard’s algorithm$ -- межпроцедурный анализ с хорошей скоростью работы, но с большим числом упрощений и обобщений. Из его описания в заметке ~\autocite{SteensgaardsNote} можно понять его сильные и слабые стороны. Его реализация так же используется в LLVM в местах, где точность не очень важна.

Так же были изучены работы Моники Лэм и Роберта Уилсона  в которых рассматривался такой подход к межпроцедурному анализу, как частично трансферные функции, который предлагает во время анализа функций строить отображения из контекста вызова в контекст, получаемый на выходе, что должно ускорять межпроцедурный анализ, отсекая повторные анализы вызовов функций не только с одним и тем же контекстом, но и подобными ему.

При существовании в компиляторе нескольких реализаций анализа псевдонимов часто прибегают к их последовательному применению по цепочке, запуская более тяжеловесные алгоритмы для уточнения только критичных участков.

%--------------------------------------------------------------------------------------------------------------------
\section{Существующая реализация анализа в ОРС}

Пользуясь описанной классификацией анализов существующую реализацию можно описать как flow-based, context-insensitive, flow-sensitive, field-sensitive (по умолчанию. Может быть и field-insensitive) анализ псевдонимов.

Существующая реализация достаточно точная, но весьма медленная с большим потреблением памяти.

\section{Ускорение анализа, параллельная реализация, чтобы нам сломать}

В существующей реализации было найдено два узких места:

\begin{itemize}
\item При большом ветвлении конец подпрограммы просматривается значительное число раз.
\item Подпрограмма анализируется при каждом её вызове.
\end{itemize}

Для обхода первого узкого места была усложнена логика обхода графа управления, которая теперь в местах ветвления пытается заглянуть вперед для нахождения более близкой точки объединения результатов анализа, нежели конец программы.

Для решения же второй проблемы была предпринята попытка воспользоватся идеями описанными в работе Лэм и Вильсона~\autocite{WilsonLamSIGPLAN95} и анализировать контексты для которых выполняются проверки, чтобы в случае вызова в одинаковых контекстах выполнять анализ однократно.

\Conc

В таблице 1 представлены результаты тестирования скорости построения результата анализа для исходного алгоритма, двух созданных модификаций и их комбинации. Числа в клетках - среднее время в миллисекундах, которое потребовалось на построение результата анализа для соответствующего бенчмарка на 20 запусках.

Сборка проекта осуществлялась g++ 4.9.2 на Ubuntu 15.04. Компьютер на котором осуществлялось тестирование имеет процессор Intel(R) Core(TM) i7-4700MQ с тактовой частотой 2.4 GHz и автоматическим её увеличением до 3.4 GHz. Так как алгоритмы анализа работают в одном потоке, частота процессора играет большую роль, чем число ядер.

\begin{table}[h!]
\label{tabl:Profiling}
\begin{tabular}{l | c | c | c | c }
Бенчмарк & Исходная реализация & Слияние & Кэширование & Оба \\
\hline \hline
linpack & 193 & 189 & 184 & 183 \\
md & 46 & 44 & 40 & 40\\ 
whetstone & 81 & 78 & 75 & 76\\
smith & 211 & 117 & 98 & 97\\
revrina & 191 & 192 & 67 & 68\\
lbm & 446 & 4474 & 341 & 4490\\
hirschberg & 604 & 570 & 309 & 306\\
hirschberg2 & 104 & 103 & 50 & 51\\
quagga & 23 & 6 & 22 & 6
\end{tabular}
\caption{Результаты тестирования}
\end{table}

Изменение обхода графа управления в процедуре не принесло большого выигрыша на основной массе тестов. Хорошо этот подход показал себя только на процедурах специального вида, где подряд много раз производится ветвление, а затем объединение.

\begin{ListingEnv}[H]
\begin{lstlisting}
void f(int* a, int* b)
{
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
    if (...)
    {
        ...
    }
    else
    {
        ...
    }
    ...
}
\end{lstlisting}
\caption{Общий вид функций, анализ которых ускоряется за счет раннего слияния результатов обхода ветвей графа управления}
\label{list:otherlevels}
\end{ListingEnv}

А вот применение идеи кэширования результатов анализа процедуры для контекстов дало выигрыш на всех достаточно сложных примерах.

\newpage % Почему-то библиография накладывалась. Быть не должно этого тут

% Печать списка литературы (библиографии)
\printbibliography[
    heading=bibintoc%
    ,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}